### Task 01 ###

# Tourist Attraction Finder

## Description
Вие сте управител на голяма туристическа агенция, но искате още да увеличите популярността на забележителностите в страната. След проведено от вас социологическо проучване разбирате, че туристите във вашата страна са мързеливи и биха посетили само най-близките забележителности до тяхното текущо местоположение. Затова решавате да разработите софтуер, който при подадени координати да намира най-близките К забележителности.

## Input Format
На стандартния вход получавате 4 числа: X и Y - координатите на текущия турист; N броя на всички забележителности и К - броя най-близки забележителности, от които се интересува туристът. На следващите N реда получавате координатите Xi и Yi на i-тата забележителност.

## Constraints
-10^5 ≤ X, Y ≤ 10^5
0 ≤ К ≤ N ≤ 2 * 10^5

## Output Format
На стандартния изход отпечатайте координатите на К-те най-близки забележителности (всеки 2 координати X и Y са на нов ред), като са сортирани по това колко са близки до туристита (най-близките са първи).

Забележка: Ако разстоянието до 2 забележителности е равно, изходът трябва да е сортиран по X и Y - първо по-малките X-ове, ако са равни - първо по-малките Y-ци.

## Sample Input 0
```
1 1 3 2
4 4 
6 0
-1 5
```

## Sample Output 0
```
4 4 
-1 5
```

### Task 02 ###

# Birthday Seating Problem

## Description
Организирате рождения си ден и сте решили да поканите точно N приятели. Един от тях обаче, този с индекс T, не ви е особено приятен и искате да му дадете по-малко храна. За да се случи това обаче, трябва да знаете на кой стол точно ще седне. Вие всъщност имате безкраен брой столове, номерирани от 0 до inf. Информацията, която имате е следната: за всеки приятел знаете точно неговото ai - време на пристигане (всички са уникални) и li - време на тръгване. Всеки от поканените приятели идва във време ai и сяда на първия свободен стол, а когато настъпи li, той освобождава стола и си тръгва.

Индексацията на столовете и приятелите започва от 0. Ако някой освобождава стола във време x, то той може да бъде зает от друг човек също във време x.

## Input Format
На първия ред се въвежда N

На следващите N реда се въвеждат по 2 числа ai и li, съответно времето, когато пристига и времето когато напуска. li винаги е строго по-голямо от съответното ai.

На следващия ред се въвежда числото T

## Constraints
1 ≤ N ≤ 500,000
0 ≤ ai ≤ 2,000,000,000 (побира се в инт)
0 ≤ T ≤ N - 1

## Output Format
На един изведете номера на стола, на който ще седне поканения приятел с индекс T

## Sample Input 0
```
3
1 4
2 3
4 6
1
```

## Sample Output 0
```
1
```

## Explanation 0
В момент 1 идва гост с индекс 0 и заема стол 0 за време 4. В момент 2 идва гост с индекс 1, стол 0 е зает, затова той сяда на стол 1, но това е и търсеният гост спрямо условието, така че изходът е 1.

## Sample Input 1
```
3
3 10
1 5
2 6
0
```

## Sample Output 1
```
2
```

### Task 03 ###

# Mini-Bus Ride Scheduler

## Description
Айя много обича да шофира и разполага с N-местно бусче, затова решава в свободното си време да печели допълнително пари, като използва бусчето си като маршрутка. Вечер след работа тръгва с бусчето си и минава по определен маршрут, докато не стигне вкъщи. Ако по пътя на произволно място група хора искат да се качат, Айя ги качва, ако има място в бусчето. Ако някой иска да слезе, маршрутката спира и пътниците слизат. Понеже е много заета, Айя минава по този път само веднъж на вечер.

Вашата задача е да помогнете на Айя да изчисли дали може да качи всички желаещи, ако знае колко човека кога се качват и кога слизат.

## Input Format
На страндартния вход получавате цяло число Q - брой заявки.

За всяка заявка получавате 2 числа: N - брой на групите от пътници, които искат да се качат в маршрутката, и C - капацитет на бусчето (колко човека се поберат да влязат освен шофьора). На следващите N реда получавате по 3 числа за всяка група: K - от колко човека се състои, X - къде искат да се качат и Y - къде искат да слязат.

## Constraints
0 ≤ Q ≤ 100
0 ≤ N ≤ 1000
0 ≤ C ≤ 10^6
0 ≤ K ≤ 1000
0 ≤ X, Y ≤ 10^5

## Output Format
На стандартния изход за всяка заявка на нов ред отпечатайте 1, ако Айя ще успее да качи всички желаещи и 0, ако няма да успее.

## Sample Input 0
```
3
2 4
2 1 5
3 3 7
2 5
2 1 5
3 3 7
2 4
2 1 5
3 6 7
```

## Sample Output 0
```
0
1
1
```