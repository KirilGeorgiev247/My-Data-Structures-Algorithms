# Task 01

Даден ви е граф, който първоначално има **N** върха и последователно му се добавят **M** ребра. От вас се иска да кажете след всяко ребро колко са на брой свързаните компоненти в графа и дали текущото добавено ребро е създало нов цикъл.

## Input Format

На първия ред се въвежда 1 числo **N**.

На следващите **M** реда се въвежда по две числа - **x** и **y**, които означават, че има двупосочно ребро между двата върха.

Бележка: **M** не се въвежда, та ребрата се четат до края на входа.

## Constraints

- `1 <= x, y <= N <= 10^6`
- `1 <= M <= 10^6`

## Output Format

На изхода, за всяко ребро се извежда следното:

Броят на свързаните компоненти след добавянето на реброто и, ако то е създало нов цикъл, се извежда "CYCLE FORMED!" след числото.

## Примери

### Sample Input 0

```
12
1 2
2 3
3 4
4 5
1 7
1 3
2 4
4 1
1 9
```

### Sample Output 0

```
11
10
9
8
7
7 CYCLE FORMED!
7 CYCLE FORMED!
7 CYCLE FORMED!
6
```

***

# Task 02

Имате даден ориентиран претеглен граф с **N** върха и **M** ребра.

Намерете дължината на минималния път от върх с номер 1 до върх с номер **N** и броя различни начини, по които може да бъде постигнат.

Два пътя се считат за различни, ако ползват поне едно различно ребро.

Hint: Ако до някой връх може да се стигне от 2 върха x и y, то начините да се стигне до него са колкото начините да се стигне до x + начините да се стигне до y.

## Input Format

На първия ред на стандартния вход ще бъдат зададени целите числа **N** и **M** – броят върхове и ребра в графа.

На следващите **M** реда ще има по една тройка числа **ui**, **vi**, **ci**, задаващи по едно насочено ребро с неговото тегло.

Възможно е да има повече от едно ребро между двойка върхове (**u**, **v**), както е и възможно да има ребро от връх до себе си.

## Constraints

- `2 <= N <= 10^5`
- `1 <= M <= 5 * 10^5`
- `1 <= ci <= 10^9`
- `1 <= ui, vi <= N`

В 33% от тестовете има уникален път до крайния връх.

## Output Format

На стандартния изход изведете разделени с интервал две цели числа – дължината на минималния път и броя различни начини, по които може да бъде постигнат.

Тъй като броят пътища може да е много голям, изведете само неговия остатък по модул  `10^9 + 7 `.

В случай, че няма път между 1 и **N**, като цена изведете "-1", а като брой пътища - "0".

## Примери

### Sample Input 0

```
5 6
1 2 10
1 4 29
2 3 50
4 3 13
4 5 24
3 5 11
```

### Sample Output 0

```
53 2
```

### Sample Input 1

```
3 1
1 2 13
```

### Sample Output 1

```
-1 0
```
