### Task 01 ###

На Боровец сте и днес е първият ви ден от новия ски сезон. Станали сте рано, с нетърпение сте хванали първия лифт, но уви след като се качвате на пистата се случва най-лошото. Пред себе си виждате... сноубордисти. След като се освестите от първоначалния шок с мъка осъзнавате, че не само няма да сте сред първите спуснали пистата, но и, че тя ще е разорана. Решавате обаче, че това няма да ви развали първото спускане за сезона и, че ще намерите най-неразораната права по която да се спуснете.

За ваше щастие по някаква невероятна случайност изглежда, че следите оставени от сноубордистите образуват двоично дърво. Добре, че и вие сте програмисти и сте минали СДА, та се сещате, че можете директно да накодите програма, която ви дава най-неразорана от сноубордисти права.

За целта ви е дадено двоично дърво с N върха, което във всеки свой връх пази колко сноубордиста са завили във участъка за който отговаря върхът. За да може по-лесно да намерите правите отсечки от пистата разполагате дървото в координатна система, където коренът е с координати (0, 0) и ако някой връх е на координати (x, y) значи, че лявото му дете е на (x - 1, y + 1), а дясното - на (x + 1, y + 1). От вас се иска за всяко число 
а да намерите сумата на върховете които са с X = a.

![Example](src/example.jpg)

**---**

Input Format

На първия ред на стандартния вход е въведено едно число - N. На всеки от следващите N реда са въведени по 3 числа - A стойността на връх в дървото, индекса на неговият ляв съсед и индеса на неговия десен съсед. Ако индексът на съседа е X, то върхът отговарящ на този съсед е въведен на ред X (ако броим от 0 и не броим първия ред, на който сме въвели N) Ако някой от тези индекси е -1, това значи, че съседът, за който отговаря не съществува. (съседът е NULL) Коренът на дървото е първият въведен връх.

Output Format

Трябва да изведете всички ненулеви суми на вертикали, започвайки от най-левият(този с най-малка X координата).

Sample Input 0

7

1 1 2 

2 3 4

3 5 6 

4 -1 -1 

5 -1 -1 

6 -1 -1

7 -1 -1

Sample Output 0

4 2 12 3 7

### Task 02 ###

В час по рисуване се наложило да нарисувате гора, обаче тъй като вие нямате нужните умения, всъщност сте нарисували само едно дърво, което обаче е сравнително голямо - N на брой възела. Учителката решила да оцени рисунките на всеки, на следния принцип: След като премахнете един възел от дървото и съответно всичките му връзки с останалите възли, ще получите 1, 2 или 3 дървета. Произведението на броя на възли в тези новополучили се дървета ще бъде вашият резултат. Тъй като на вас много ви трябва отлична оценка, трябва да разберете какъв е максималният резултат, който може да се постигне при премахване на някой възел от вашето дърво.

**---**

Input Format

На първия ред ви е даден N - броя на възлите на дървото.

На всеки от следващите N реда са ви дадени разделени с интервал left и right. Номерът на реда, отговаря на индекса на възела (започват от 0). Винаги 0 ще ви бъде коренът на дървото.

left съответства на индекса на левия наследник.

right съответства на индекса на десния наследник.

Output Format

Изведете 1 число, максималният резултат при премахване на някой от възлите в дървото.

Sample Input 0

6

1 2

3 4

-1 5

-1 -1

-1 -1

-1 -1

Sample Output 0

6

Explanation 0

    0

   / \

  1   2

 / \   \

3   4   5

Резултат при премахване на 0: 3 * 2 = 6

Резултат при премахване на 1: 3 * 1 * 1 = 3

Резултат при премахване на 2: 4 * 1 = 4

Резултат при премахване на 3: 5

Резултат при премахване на 4: 5

Резултат при премахване на 5: 5

### Task 03 ###

Понеже вие сте отличен ученик и в час по математика ви е твърде скучно и вместо да решавате задачи по едно време започвате да си драскате нещо в тетрадката. В края на часа започвате да анализирате вашите драсканици и всъщност виждате дърво. Тогава ви хрумва идеята да намерите кой е пътят, който минава през всеки възел точно по веднъж и има максимална стойност на сбора от възлите, през които минава.

**---**

Input Format

На първия ред ви е даден N - броя на възлите на дървото.

На всеки от следващите N реда са ви дадени разделени с интервал val, left и right. Номерът на реда, отговаря на индекса на възела (започват от 0). Винаги 0 ще ви бъде коренът на дървото.

val съответства на стойността на възела.

left съответства на индекса на левия наследник.

right съответства на индекса на десния наследник.

Output Format

Изведете 1 число, отговарящо на максималния път.

Sample Input 0

3

1 1 2

2 -1 -1

5 -1 -1

Sample Output 0

8

Explanation 0

   1

 /   \

2     5

Тук лесно се вижда, че най-дългият път е 8

Sample Input 1

5

-5 1 2

2 -1 -1

10 3 4

3 -1 -1

5 -1 -1

Sample Output 1

18

Explanation 1

    -5

   /  \ 

  2    10

       / \

      3   5

Най-дългият път е 3 -> 10 -> 5, през възли с индекси 3,2,4
